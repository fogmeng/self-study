### 背景

​	在分布式系统中需要对大量的数据进行唯一标识，分库分表后的id,实现幂等标识等等，总的来说业务系统对id有以下要求：

1. 全局唯一性。
2. 趋势递增。mysql使用的是聚集索引，底层采用B-tree存储数据，在主键的选择上尽量采用有序主键。
3. 单调递增。下一个id大于上一个id。事务版本号、IM增量消息，排序等。
4. 信息安全：如果id是连续自增，恶意用爬取工作就简单了，之间按照自增顺序爬取页面。如果订单是连续自增的话，就可以大概统计一天的下单量。

### 常见方案

- uuid方案

  1. 优点：

     * 性能高，本地生成，无网络消耗。

  2. 缺点

     * 不易于存储，太长，通常是字符表示。

     * ID作为主键时不适合。

       ① MySQL官方有明确的建议主键要尽量越短越好[4]，36个字符长度的UUID不符合要求。

       ② 对MySQL索引不利：如果作为数据库主键，在InnoDB引擎下，UUID的无序性可能会引起数据位置频繁变动，严重影响性能。  

     * 信息不安全：基于MAC地址生成UUID的算法可能会造成MAC地址泄露 

- 雪花方案

  这种方案大致来说是一种划分命名空间来生成id方案，这种方案把64bit分成多段：标识（1bit）+41bit时间戳+10bit的workerID+10bit的序列号。

  1. 优点：
     - 毫秒数在高位，自增序列在低位，整个ID趋势递增
     - 不依赖第三方系统（数据库等），稳定性高，性能高。
     - 可以根据自身业务特点配置bit位。
  2. 缺点：
     * 强依赖机器时钟，如果时钟回拨或更改，可能会造成重复。

- 数据库生成

  给字段设定auto_increment和auto_increment_offset来保证自增id

  1. 优点：
     * 简单，利用数据库系统自动生成，成本小，有DBA专业维护
     * ID单调自增，可以实现一些对ID有特殊需求的业务。
  2. 缺点：
     * 强依赖DB,DB不可用是致命问题。
     * ID性能瓶颈在于单台mysql读写性能。
     * ID顺序自增，信息安全问题。

- zk+雪花方案

  基于上述雪花方案，增加zk获取workerid,本地缓存workid若依赖zk,解决时钟回拨问题。

- buffer+数据库方案

  基于数据库方案优化。biz_tag,max_id,step,update_time,desc.

  - 原方案每次获取id都得读写数据库，造成数据库压力大，采用批量获取一个segment（step决定大写）号段的值,用完之后再去取新的值。大大减轻数据库的压力。
  - biz_tag区分各个业务，相互隔离，互不影响。也方便以后分库分表扩容。
  - 双buffer优化，当segment到达某个阈值（当前0.75）时，启用线程获取下一个segment



> https://tech.meituan.com/MT_Leaf.html

